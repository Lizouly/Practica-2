# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1trkvPqdSQU6hwUwpY-p8-nBql1NzL70G
"""

class Cola:
    def __init__(self):
        """Inicializa una cola vacía."""
        self.items = []

    def esta_vacia(self):
        """Devuelve True si la cola está vacía, False en caso contrario."""
        return len(self.items) == 0

    def encolar(self, item):
        """Agrega un elemento a la cola."""
        self.items.insert(0, item)

    def desencolar(self):
        """Remueve y devuelve el primer elemento de la cola."""
        if not self.esta_vacia():
            return self.items.pop()
        else:
            raise IndexError("La cola está vacía")

    def tamano(self):
        """Devuelve el tamaño actual de la cola."""
        return len(self.items)

import random

class Cola:
    def __init__(self):
        """Inicializa una cola vacía."""
        self.items = []

    def esta_vacia(self):
        """Devuelve True si la cola está vacía, False en caso contrario."""
        return len(self.items) == 0

    def encolar(self, item):
        """Agrega un elemento a la cola."""
        self.items.insert(0, item)

    def desencolar(self):
        """Remueve y devuelve el primer elemento de la cola."""
        if not self.esta_vacia():
            return self.items.pop()
        else:
            raise IndexError("La cola está vacía")

    def tamano(self):
        """Devuelve el tamaño actual de la cola."""
        return len(self.items)


class CentroLlamadas:
    def __init__(self, num_lineas=19):
        """Inicializa el centro de llamadas con un número específico de líneas."""
        self.num_lineas = num_lineas
        self.cola_normal = Cola()
        self.cola_premier = Cola()
        self.tiempo_total_espera_premier = 0
        self.max_tiempo_espera_premier = 0
        self.clientes_atendidos = 0
        self.clientes_no_atendidos = 0  # Para contar clientes no atendidos (cola se satura)

    def generar_tiempo_interarribo(self):
        """Genera un tiempo de interarribo entre 1 y 3 minutos con distribución uniforme."""
        return random.uniform(1, 3)

    def generar_tiempo_atencion(self):
        """Genera un tiempo de atención entre 1 y 81 minutos con distribución uniforme."""
        return random.uniform(1, 81)

    def es_cliente_premier(self):
        """Determina si un cliente pertenece al segmento premier (1 de cada 6)."""
        return random.randint(1, 6) == 1

    def simular_cliente(self, tiempo_simulacion):
        """Simula la llegada y atención de clientes durante un tiempo dado."""
        tiempo_arribo = 0
        lineas_libres = self.num_lineas  # Gestiona cuántas líneas están libres

        while tiempo_arribo < tiempo_simulacion:
            # Generar tiempo interarribo y avanzar el tiempo de arribo
            tiempo_interarribo = self.generar_tiempo_interarribo()
            tiempo_arribo += tiempo_interarribo

            # Determinar si es un cliente premier o normal
            cliente_premier = self.es_cliente_premier()

            # Encolar el cliente en la cola correspondiente
            if cliente_premier:
                self.cola_premier.encolar(tiempo_arribo)
            else:
                self.cola_normal.encolar(tiempo_arribo)

            # Procesar clientes mientras haya líneas disponibles
            while lineas_libres > 0 and (not self.cola_premier.esta_vacia() or not self.cola_normal.esta_vacia()):
                if not self.cola_premier.esta_vacia():
                    # Atender cliente premier
                    cliente_atendido = self.cola_premier.desencolar()
                    tiempo_atencion = self.generar_tiempo_atencion()

                    tiempo_espera = tiempo_arribo - cliente_atendido
                    self.tiempo_total_espera_premier += tiempo_espera
                    self.max_tiempo_espera_premier = max(self.max_tiempo_espera_premier, tiempo_espera)

                elif not self.cola_normal.esta_vacia():
                    # Atender cliente normal
                    cliente_atendido = self.cola_normal.desencolar()
                    tiempo_atencion = self.generar_tiempo_atencion()

                # Liberar una línea después de atender un cliente
                lineas_libres -= 1
                self.clientes_atendidos += 1

            # Restaurar las líneas para la próxima iteración
            lineas_libres = self.num_lineas

        # Contar clientes que no fueron atendidos porque la cola se saturó
        self.clientes_no_atendidos += self.cola_normal.tamano() + self.cola_premier.tamano()

    def resultados(self):
        """Imprime los resultados finales de la simulación."""
        print(f"\nClientes atendidos: {self.clientes_atendidos}")
        print(f"Clientes no atendidos (sistema saturado): {self.clientes_no_atendidos}")
        print(f"Máximo tiempo de espera para clientes premier: {self.max_tiempo_espera_premier:.2f} minutos.")
        if self.clientes_atendidos > 0:
            promedio_espera_premier = self.tiempo_total_espera_premier / self.clientes_atendidos
            print(f"Promedio tiempo de espera para clientes premier: {promedio_espera_premier:.2f} minutos.")
        else:
            print("No se atendieron clientes premier.")

    def determinar_lineas_minimas(self, tiempo_simulacion):
        """Determina el número mínimo de líneas necesario para evitar la saturación."""
        for lineas in range(1, 30):  # Probar con diferentes cantidades de líneas
            print(f"\nSimulando con {lineas} líneas...")
            self.__init__(num_lineas=lineas)  # Reiniciar el centro de llamadas con nuevas líneas
            self.simular_cliente(tiempo_simulacion)
            if self.clientes_no_atendidos == 0:
                print(f"El número mínimo de líneas sin saturar el sistema es: {lineas}")
                break
        else:
            print("El sistema se satura incluso con 30 líneas.")

if __name__ == "__main__":
    # Configurar la simulación para 24 horas (1440 minutos)
    tiempo_simulacion = 24 * 60

    # Determinar el número mínimo de líneas necesarias sin saturar
    centro_llamadas = CentroLlamadas()
    centro_llamadas.determinar_lineas_minimas(tiempo_simulacion)

    # Realizar una simulación con el número de líneas predeterminado (19) y mostrar resultados
    centro_llamadas.simular_cliente(tiempo_simulacion)
    centro_llamadas.resultados()